<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Lua Jepsen documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Lua Jepsen</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>jepsen.checker</strong></li>
  <li><a href="../modules/jepsen.client.html">jepsen.client</a></li>
  <li><a href="../modules/jepsen.clock.html">jepsen.clock</a></li>
  <li><a href="../modules/jepsen.thread_coroutine.html">jepsen.thread_coroutine</a></li>
  <li><a href="../modules/jepsen.thread_fiber.html">jepsen.thread_fiber</a></li>
  <li><a href="../modules/jepsen.gen.html">jepsen.gen</a></li>
  <li><a href="../modules/jepsen.history.html">jepsen.history</a></li>
  <li><a href="../modules/jepsen.html">jepsen</a></li>
  <li><a href="../modules/jepsen.log.html">jepsen.log</a></li>
  <li><a href="../modules/jepsen.nemesis.html">jepsen.nemesis</a></li>
  <li><a href="../modules/jepsen.op.html">jepsen.op</a></li>
  <li><a href="../modules/jepsen.runner.html">jepsen.runner</a></li>
  <li><a href="../modules/jepsen.thread.html">jepsen.thread</a></li>
  <li><a href="../modules/jepsen.utils.html">jepsen.utils</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/README.md.html">README</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>jepsen.checker</code></h1>
<p>Validates that a history is correct with respect to some model.</p>
<p>


<p> One of the main challenges with checking consistency of a history operations
 is a time required to run the linearizability checker. The linearizability
 checker, while super useful and a product of very good research, has some
 limitations. The time the checker takes to analyze a history grows
 exponentially with the number of operations. Furthermore, ambiguous
 operations cause exponential growth as well. So we have a problem: we want
 to push the clients as hard as we can for the duration of a test, but if we
 push the clients too hard, the checker may run out of memory and fail to
 analyze the history. This also means we want the tests to execute as fast as
 possible, but this will shrink the surface area for finding a bug.</p>

<p> In general, checking linearizability is
 <a href="http://en.wikipedia.org/wiki/NP-complete">NP-complete</a> and so writing an
 efficient linearizability checker is inherently difficult.</p>

<h3>Example</h3>

<p> Consider the following history <code>H</code> of read and write operations on a
 register:</p>


<pre>
write(<span class="number">1</span>)        read() : <span class="number">2</span>
<span class="comment">---------|    |------------|
</span>
              write(<span class="number">2</span>)
            |<span class="comment">----------|</span>
</pre>

<p> The <code>write(1)</code> happens-before the two remaining <code>read()</code> and <code>write(2)</code>
 operations. Note that <code>read()</code> and <code>write(2)</code> happen concurrently because
 neither finishes before the other starts. Then <code>H</code> is linearizable because
 the operations can be reordered as follows:</p>


<pre>
write(<span class="number">1</span>); write(<span class="number">2</span>); read()
</pre>

<p> where the read returns the last written register value, namely 2. By
 contrast, the following history <code>H&apos;</code> is non-linearizable because there is no
 valid reordering of reads and writes that satisfies the expected behaviour
 of a register:</p>


<pre>
write(<span class="number">1</span>)        read() : <span class="number">2</span>
<span class="comment">---------|    |------------|
</span>
                                 write(<span class="number">2</span>)
                               |<span class="comment">----------|</span>
</pre>

<h3>Transactional safety checkers</h3>

<ul>
    <li><a href="https://github.com/anishathalye/porcupine">Porcupine</a> is a fast
    linearizability checker for testing the correctness of distributed systems.
    It takes a sequential specification as executable Go code, along with a
    concurrent history, and it determines whether the history is linearizable
    with respect to the sequential specification. Porcupine also implements a
    visualizer for histories and linearization points.</li>
    <li><a href="https://github.com/ept/hermitage">Hermitage</a> is an attempt to nail down
    precisely what different database systems actually mean with their isolation
    levels. It's a suite of tests that simulates various concurrency issues -
    some common, some more obscure - and documents how different databases
    handle those situations.</li>
    <li><a href="https://github.com/wgolab/WatCA">WatCA</a> is a tool for analyzing
    consistency in distributed storage systems and in concurrent data
    structures.</li>
    <li><a href="https://github.com/pviotti/conver/">conver</a> - is a testing tool that
    verifies implementations of the most common non-transactional consistency
    models. See
    <a href="https://www.info.ucl.ac.be/~pvr/papoc-2016-viotti-cr.pdf">paper</a> and
    <a href="https://github.com/jepsen-io/knossos/blob/master/research/papoc_viotti.pdf">slides</a>.</li>
</ul>

<h3>Papers</h3>

<ul>
    <li>Fiagit Attiya, Jennifer L. Welch, Sequential Consistency versus Linearizability</li>
    <li>Adya, 'Weak Consistency'</li>
    <li>Adya, Liskov, O'Neil, 'Generalized Isolation Level Definitions'</li>
    <li>Adya, Liskov, O'Neil, 'Towards an Isolation Level Standard'</li>
    <li>Bailis, Davidson, Fekete, et al, 'Highly Available Transactions'</li>
    <li>Cerone, Bernardi, Gotsman, 'A Framework for Transactional Consistency Models with Atomic Visibility'</li>
    <li>Fekete, Liarokapis, O'Neil, O'Neil, 'Making Snapshot Isolation Serializable'</li>
    <li>Cerone-SI: Cerone, Gotsman, 'Analysing Snapshot Isolation'</li>
    <li>Daudjee, Salem, 'Lazy Database Replication with Ordering Guarantees'</li>
    <li>Daudjee-SI: Daudjee, Salem, 'Lazy Database Replication with Snapshot Isolation'</li>
    <li>Bernstein, Hazilacos, Goodman, 'Concurrency Control and Recovery in Database Systems'</li>
    <li>Zuikeviciute, Pedone, 'Correctness Criteria for Database Replication'</li>
    <li>Liu, Ã–lveczky, et al, 'ROLA: A New Distributed Transaction Protocol and Its Formal Analysis'</li>
    <li>Cahill, 'Serializable Isolation for Snapshot Databases'</li>
    <li>Jorwekar, Ramamritham, Fekete, Sudarshan 'Automating the Detection of Snapshot Isolation Anomalies'</li>
</ul>
</p>



<br/>
<br/>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2021-12-11 10:23:26 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
